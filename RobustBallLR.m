%% Description: ROSSDP-Ball Uncertainty Set-G/M/1
clear
clc

% Inputs:
% I: The set of demand points
% J: The set of potential facility locations
% f: Setup cost (J)
% c: Access cost (I*J)
% xinom: Nominal demand (I)
% K: Number of breakpoints
tic
load('p470.mat');
params.outputflag = 0;
params.MIPGapAbs = 0.001;
params.IntFeasTol = 0.001;
alpha = 50000*rand(I,1);

f=10*ones(J,1);
t=200; % Waiting time penalty
CV=2; % CV
R=(CV^2+1)/2;
xihat=Max_Dev;

K = 10;
Deviation = abs(bsxfun(@minus,SampleMat, xinom));
% Uncertainty Budget-Ball Uncertainty Set
r = zeros(K,1);  
for n=1:K
    m = Deviation(n,:)*eye(I)*(Deviation(n,:))';
    r(n,:) = sqrt(m);
end
rhoBall = prctile(r,90);

r = rhoBall;
% r = 0;
%% Piecewise Approximation-Generating Breaking Points
%g=@(q)q^2/(1-q);
%gderiv=@(q)(1/(1-q)^2)-1 ----> First Derivative of g
ghat=@(p)p^2/(1-p);%----> Linear Approximation
%T=@(q)q^2*(1+ghat(p)+p)-2*q*(ghat+p)+ghat(p)----> for finding q
%B=@(p)p^2*(1+gderiv(q))-p*(gderiv(q)+gderiv(q)*q-g(q)-e)+gderiv(q)*q-g(q)-e
p=0;
e=0.001;
bp=0; % Breaking Points
Tp=[]; % The set of Tangency Points
while p < 0.99
    r1=[e-1/(1-p) 2*p/(1-p)-2*e e-p^2/(1-p)];
    qq=roots(r1);
    for i=1:size(qq,1)
        if qq(i) > p
            q=qq(i);
        else
        end
    end
    Tp=[Tp q];
    r2=[1/(1-q)^2 e-2*q/(1-q)^2 q^2/(1-q)^2-e];
    pp=roots(r2);
    for n=1:size(pp,1)
        if pp(n) > q
            pnew=pp(n);
        else
        end
    end
    bp=[bp pnew];
    p=pnew;
end

K=length(bp);
ghatnew=zeros(1,K);
for k=1:K
ghatnew(:,k)=ghat(bp(k));
end

%% Subproblem [LSPj]:
UB=Inf;
LB=-Inf;
Newcut=[];
RHNewcut=[];
iter = 0;
X=[];
TotalSPtime = 0;
TotalMPtime = 0;

sol=zeros(J,I+3+K+1);                   % Final Solution of All the Subproblems
beta=zeros(J,1);                        % A vector of all the Obj. values of Subproblems

% Order of variables: y_ij, mu_j, rho_j, theta_j, lambda_jk ,u'_j
% Equality Constraints:
Aeq1=[sparse(1,I), 0 , 1 , 0 , -bp, 0];
beq1=0;

Aeq2=[sparse(1,I), 0 , 0 , 1 , -ghatnew, 0];
beq2=0;

Aeq3=[sparse(1,I), 0 , 0 , 0 , ones(1,K), 0];
beq3=1;

Aeq = [Aeq1;Aeq2;Aeq3];
beq =[beq1;beq2;beq3];

% SOC Constraints:
%(2):
L = zeros(I+3+K+1,1);
L(I+3+K+1,1)= r;
Q2=sparse(I+3+K+1,I+3+K+1);
Q2(1:I,1:I)=diag(xinom);
Q2(I+1,I+2)=-1; 
modela.quadcon(1).Qc= Q2;
modela.quadcon(1).q = L;
modela.quadcon(1).q = zeros(I+3+K+1,1);
modela.quadcon(1).rhs = 0;
modela.quadcon(1).name = sprintf('cone%d',1);

%(3):
Q3=sparse(I+3+K+1,I+3+K+1);
Q3(1:I,1:I)=diag(ones(1,I));
Q3(I+3+K+1,I+3+K+1)=-1; 
modela.quadcon(2).Qc= Q3;
modela.quadcon(2).q = zeros(I+3+K+1,1);
modela.quadcon(2).rhs = 0;
modela.quadcon(2).name = sprintf('cone%d',2);

% SOS2
modela.sos.type = 2;
modela.sos.index = I+3+(1:K)';
modela.sos.wieght = (1:K)';

modela.A = Aeq;
modela.rhs = beq;
modela.sense = repmat('=',1,3);
modela.vtype = [repmat('B',1,I),repmat('C',1,3+K+1)];
modela.lb = zeros(1,I+3+K+1);
modela.ub = [ones(1,I),Inf,1,Inf,ones(1,K),Inf];

validcut = [speye(J,J), sparse(J,I)];
RHvalidcut = zeros(J,1);
    
while UB-LB > 0.01 && sum(TotalSPtime)+sum(TotalMPtime) < 10000
iter = iter+1;

% Objective function
% Order of variables: y_ij, mu_j, rho_j, theta_j, lambda_jk,u'_j
% For y_ij
A=c.*repmat(xinom'+r/sqrt(I*J),1,J);
B=repmat(alpha,1,J);
C=reshape(A-B,1,I*J);
tic
for j=1:J
    modela.obj = [C(1,(j-1)*I+1:I*j), f(j,1), t ,t*R ,zeros(1,K), 0];
    modela.modelsence = 'Min';
    resultj = gurobi(modela,params);
    solj = resultj.x;
    sol(j,:) = solj';
    betaj = resultj.objval;
    beta(j,1) = betaj;
end
SPtime = toc;
TotalSPtime = [TotalSPtime;SPtime];
LB = max(LB,sum(beta)+sum(alpha));
y = sol(:,1:I);
mu = sol(:,I+1);
rho = sol(:,I+2);
theta = sol(:,I+3);
lambda = sol(:,I+4:I+3+K);
H = [y,mu,rho,theta];
X=[X;H];

%% Master Problem-Kelly's Cutting Plane [DMP]:
% Order of variables: beta_j, alpha_i
% Generating Cuts:
D = c'.*repmat(xinom+r/sqrt(I*J),J,1);
P = [D, f, t.*ones(J,1), t*R.*ones(J,1)].*H;
F = sum(P');
Aineq = [speye(J,J), y];
bineq = F';

Newcut=[Newcut;Aineq];
RHNewcut=[RHNewcut;bineq];

modelb.obj = [-ones(1,J), -ones(1,I)];
modelb.modelsence='Min';
modelb.A =[validcut;Newcut];
modelb.rhs = [RHvalidcut;RHNewcut];
modelb.sense = repmat('<',1,J+J*iter);
modelb.vtype = repmat('C',1,J+I);
modelb.lb = [-Inf(1,J),zeros(1,I)];
modelb.ub = Inf(1,J+I);
tic
result = gurobi(modelb,params);
MPtime = toc;
TotalMPtime = [TotalMPtime;MPtime];
solMaster = result.x;
valMaster = result.objval;

UB = -valMaster;
alpha = solMaster(J+1:J+I);
fprintf('\niter=%2g, LB=%2.3f, UB=%2.3f , SPtime=%2.3f , MPtime=%2.3f\n\n', iter, LB, UB, SPtime, MPtime);
end

%% Getting the cuts generated by each subproblem
v=1;
for j=1:J
    for i=j:J:(iter-1)*J+j
        xx(v,:)=X(i,:);
        v=v+1;
    end
end
tt=1;
k=0;
CC=[];
for p=1:J
    for j=1:iter
        CC(j,:,p)=xx(tt,:);
        tt=tt+1;
    end
end

%% Dantzing-Wolfe Decomposition [MP]
% Order of variables:  w_j
% (alpha_i):
Xtrapy=(X(:,1:I))';
Aeqdzw1= Xtrapy;
beqdzw1=ones(I,1);

% (beta_j):
Aeqdzw2= repmat(speye(J,J),1,iter);
beqdzw2=ones(J,1);

% Objective Function
PP = repmat([D, f, t.*ones(J,1), t*R.*ones(J,1)],iter,1).*X;
O=sum(PP');
modelc.obj = O;
modelc.modelsence='Min';
modelc.A =[Aeqdzw1;Aeqdzw2];
modelc.rhs = [beqdzw1;beqdzw2];
modelc.sense = repmat('=',1,I+J);
modelc.vtype = repmat('C',1,size(X,1));
modelc.lb = zeros(1,size(X,1));
modelc.ub = Inf(1,size(X,1));
result = gurobi(modelc,params);
soldzw = result.x;
valdzw = result.objval;
w = soldzw';

%% Getting the w for each subproblem
vv=0;
for j=1:J
    for i=j:J:(iter-1)*J+j
        vv=vv+1;
        uu(:,vv)=w(:,i);
    end
end

W=[];
for j=1:J
    W=[W;uu(:,(j-1)*iter+1:(j-1)*iter+iter)];
end

%% Getting the Optimal Solution
optimalsol=[];
for n=1:J
    optimalsol=[optimalsol; W(n,:)*CC(:,:,n)];
end

%**************************************************************************
gap=(valdzw-LB)/LB;

y = optimalsol(:,1:I)';
mu = optimalsol(:,I+1);
rho = optimalsol(:,I+2);
theta = optimalsol(:,I+3);
utilization = 100*rho;
save ROBa490a y mu utilization LB UB

timeElapsed = toc;

fprintf('valdzw=%2.3f, gap=%2.3f \n\n', valdzw, gap);
sum(TotalSPtime)+sum(TotalMPtime)
