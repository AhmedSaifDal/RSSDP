%% Description: Deterministic Problem-G/M/1
clear
clc

% Inputs:
% I: The set of demand points
% J: The set of potential facility locations
% f: Setup cost (J)
% c: Access cost (I*J)
% xinom: Nominal demand (I)
% K: Number of breakpoints
tic
load('p170.mat');
params.outputflag = 0;
params.MIPGapAbs = 0.01;
params.IntFeasTol = 0.001;
delta = 30000*rand(I,1);

f=10*ones(J,1);
t=100; % Waiting time penalty
CV=0.5; % CV
R=(CV^2+1)/2;
%% Piecewise Approximation-Generating Breaking Points
%g=@(q)q^2/(1-q);
%gderiv=@(q)(1/(1-q)^2)-1 ----> First Derivative of g
ghat=@(p)p^2/(1-p);%----> Linear Approximation
%T=@(q)q^2*(1+ghat(p)+p)-2*q*(ghat+p)+ghat(p)----> for finding q [substitute ghat(p)=g(p)-e]
%B=@(p)p^2*(1+gderiv(q))-p*(gderiv(q)+gderiv(q)*q-g(q)-e)+gderiv(q)*q-g(q)-e
p=0;
e=0.001;
bp=0; % Breaking Points
Tp=[]; % The set of Tangency Points
while p < 0.99
    r1=[1/(1-p)-e -2*p/(1-p)+2*e p^2/(1-p)-e];
    qq=roots(r1);
    for i=1:size(qq,1)
        if qq(i) > p
            q=qq(i);
        else
        end
    end
    Tp=[Tp q];
    r2=[1/(1-q)^2 e-2*q/(1-q)^2 q^2/(1-q)^2-e];
    pp=roots(r2);
    for n=1:size(pp,1)
        if pp(n) > q
            pnew=pp(n);
        else
        end
    end
    bp=[bp pnew];
    p=pnew;
end

K=length(bp);
ghatnew=zeros(1,K);
for k=1:K
ghatnew(:,k)=ghat(bp(k));
end

%% Subproblem [LSPj]:
UB=Inf;
LB=-Inf;
Newcut=[];
RHNewcut=[];
iter = 0;
X=[];                             % All the Generated Cut
TotalSPtime = 0;
TotalMPtime = 0;

sol=zeros(J,I+1+1+1+K);           % Final Solution of All the Subproblems
beta=zeros(J,1);                  % A vector of all the Obj. values of Subproblems 

% Order of variables:  y_ij, mu_j, rho_j, theta_j, lambda_jk
% Equality Constraints:
% bp: Breakpoints (1*K vector)
Aeq1=[sparse(1,I), 0 , 1 , 0 , -bp];
beq1=0;

Aeq2=[sparse(1,I), 0 , 0 , 1 , -ghatnew];
beq2=0;

Aeq3=[sparse(1,I), 0 , 0 , 0 , ones(1,K)];
beq3=1;

Aeq = [Aeq1;Aeq2;Aeq3];
beq = [beq1;beq2;beq3];

% SOC Constraint:
% Order of variables:  y_ij, mu_j, rho_j, theta_j, lambda_jk
Q = sparse(I+3+K,I+3+K);
Q(1:I,1:I) = diag(xinom);
Q(I+1,I+2) = -1; 
modela.quadcon.Qc = Q;
modela.quadcon.q = zeros(I+3+K,1);
modela.quadcon.rhs = 0;

% SOS2
modela.sos.type = 2;
modela.sos.index = I+3+(1:K)';
modela.sos.wieght = (1:K)';

modela.A = Aeq;
modela.rhs = beq;
modela.sense = repmat('=',1,3);
modela.vtype = [repmat('B',1,I),repmat('C',1,3+K)];
modela.lb = zeros(1,I+3+K);
modela.ub = [ones(1,I),Inf,1,Inf,ones(1,K)];

% validcut = [speye(J,J), sparse(J,I)];
% RHvalidcut = zeros(J,1);

while UB-LB > 0.01 && sum(TotalSPtime)+sum(TotalMPtime) < 13500
iter = iter+1;

% Objective function
% For y_ij
A = reshape(c.*repmat(xinom',1,J)-repmat(delta,1,J),1,I*J);

tic
for j=1:J
    modela.obj = [A(1,(j-1)*I+1:I*j), f(j,1), t ,t*R ,zeros(1,K)];
    modela.modelsence = 'Min';
    resultj = gurobi(modela,params);
    solj = resultj.x;
    sol(j,:) = solj';
    betaj = resultj.objval;
    beta(j,1) = betaj;
end
SPtime = toc;
TotalSPtime = [TotalSPtime;SPtime];
LB = max(LB,sum(beta)+sum(delta));
y = sol(:,1:I);
mu = sol(:,I+1);
rho = sol(:,I+2);
theta = sol(:,I+3);
lambda = sol(:,I+4:I+3+K);
H = [y,mu,rho,theta];
X=[X;H];

%% Master Problem-Kelly's Cutting Plane [DMP]:
% Order of variables: beta_j, delta_i
% Generating Cuts:
B = c'.*repmat(xinom,J,1);
P = [B, f, t.*ones(J,1), t*R.*ones(J,1)].*H;
F = sum(P');
Aineq = [speye(J,J), y];
bineq = F';

Newcut=[Newcut;Aineq];
RHNewcut=[RHNewcut;bineq];

modelb.obj = [-ones(1,J), -ones(1,I)];
modelb.modelsence='Min';
% modelb.A =[validcut;Newcut];
% modelb.rhs =[ RHvalidcut;RHNewcut];
modelb.A =Newcut;
modelb.rhs =RHNewcut;
% modelb.sense = repmat('<',1,J+J*iter);
modelb.sense = repmat('<',1,J*iter);
modelb.vtype = repmat('C',1,J+I);
modelb.lb = [-Inf(1,J),zeros(1,I)];
modelb.ub = Inf(1,J+I);
tic
result = gurobi(modelb,params);
MPtime = toc;
TotalMPtime = [TotalMPtime;MPtime];
solMaster = result.x;
valMaster = result.objval;

UB = -valMaster;
delta = solMaster(J+1:J+I);
fprintf('\niter=%2g, LB=%2.3f, UB=%2.3f , SPtime=%2.3f , MPtime=%2.3f\n\n', iter, LB, UB, SPtime, MPtime);
end

%% Getting the cuts generated by each subproblem
v=1;
for j=1:J
    for i=j:J:(iter-1)*J+j
        xx(v,:)=X(i,:);
        v=v+1;
    end
end
tt=1;
k=0;
CC=[];
for p=1:J
    for j=1:iter
        CC(j,:,p)=xx(tt,:);
        tt=tt+1;
    end
end

%% Dantzing-Wolfe Decomposition [MP]
% Order of variables:  w_j
% (delta_i):
Xtrapy=(X(:,1:I))';
Aeqdzw1= Xtrapy;
beqdzw1=ones(I,1);

% (beta_j):
Aeqdzw2= repmat(speye(J,J),1,iter);
beqdzw2=ones(J,1);

% Objective Function
PP = repmat([B, f, t.*ones(J,1), t*R.*ones(J,1)],iter,1).*X;
O=sum(PP');
modelc.obj = O;
modelc.modelsence='Min';
modelc.A =[Aeqdzw1;Aeqdzw2];
modelc.rhs = [beqdzw1;beqdzw2];
modelc.sense = repmat('=',1,I+J);
modelc.vtype = repmat('C',1,size(X,1));
modelc.lb = zeros(1,size(X,1));
modelc.ub = Inf(1,size(X,1));
result = gurobi(modelc,params);
soldzw = result.x;
valdzw = result.objval;
w = soldzw';

%% Getting the w for each subproblem
vv=0;
for j=1:J
    for i=j:J:(iter-1)*J+j
        vv=vv+1;
        uu(:,vv)=w(:,i);
    end
end

W=[];
for j=1:J
    W=[W;uu(:,(j-1)*iter+1:(j-1)*iter+iter)];
end

%% Getting the Optimal Solution
optimalsol=[];
for n=1:J
    optimalsol=[optimalsol; W(n,:)*CC(:,:,n)];
end

%**************************************************************************
gap=(valdzw-LB)/LB;

y = optimalsol(:,1:I)';
mu = optimalsol(:,I+1);
rho = optimalsol(:,I+2);
theta = optimalsol(:,I+3);
accesscost = reshape(c.*repmat(xinom',1,J),1,I*J)*reshape(y,I*J,1);
setupcost = f'*mu;
waitingcost = t*R*sum(theta)+t*sum(rho);
accpercentage = 100*(accesscost/valdzw);
setuppercentage = 100*(setupcost/valdzw);
waitingpercentage = 100*(waitingcost/valdzw);
utilization = 100*rho;
% save NP3b y mu accpercentage setuppercentage waitingpercentage utilization LB UB

timeElapsed = toc;

fprintf('valdzw=%2.3f, gap=%2.3f \n\n', valdzw, gap);
accpercentage
setuppercentage
waitingpercentage
min(utilization)
max(utilization)
sum(TotalSPtime)+sum(TotalMPtime)

